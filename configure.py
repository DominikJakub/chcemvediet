# vim: expandtab
# -*- coding: utf-8 -*-
import json
import re
import string
import random
from textwrap import dedent

class JsonFile(object):
    def __init__(self, inputfile, outputfile=None):
        self.inputfile = inputfile
        self.outputfile = outputfile or inputfile
        with open(inputfile) as json_file:
            self.data = json.load(json_file)

    def __enter__(self):
        return self.data

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.outputfile, u'w') as json_file:
                json.dump(self.data, json_file, indent=2)

class Configure(object):
    def __init__(self, filename=u'configure.json'):
        self.filename = filename
        try:
            with open(filename) as json_file:
                self.data = json.load(json_file)
        except IOError:
            self.data = {}

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as json_file:
                json.dump(self.data, json_file, indent=2, sort_keys=True)

    def auto(self, key, default):
        return self.data.setdefault(key, default)

    def input(self, key, prompt, default=u'', required=False):
        configured = self.data.get(key, default)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured)) or configured
            if required and not inputed:
                print(u'\nError: The value is required.')
                continue
            break
        self.data[key] = inputed
        return inputed

    def input_choice(self, key, prompt, choices, default=u''):
        configured = self.data.get(key, default)
        configured_choice = u''
        print(u'\n%s:' % prompt)
        for idx, (value, label) in enumerate(choices):
            print(u' %d) %s' % (idx+1, label))
            if value == configured:
                configured_choice = u'%d' % (idx+1)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured_choice)) or configured_choice
            if not inputed:
                print(u'\nError: The value is required.')
                continue
            try:
                value, label = choices[int(inputed)-1]
            except (ValueError, IndexError):
                print(u'\nError: Invalid choice.')
                continue
            break
        self.data[key] = value
        return value

class Settings(object):
    def __init__(self, filename=u'chcemvediet/settings/configured.py'):
        self.filename = filename
        self.lines = []
        self.comment(u'This file was autogenerated by `configure.py`. Do NOT edit it.')

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as settings_file:
                settings_file.write(u'\n'.join(self.lines) + u'\n')

    def comment(self, text):
        for line in text.split(u'\n'):
            self.lines.append(u'# %s' % line)

    def include(self, filaname):
        self.lines.append(u'execfile(os.path.join(SETTINGS_PATH, %s))' % repr(filaname))

    def setting(self, name, value):
        self.lines.append(u'%s = %s' % (name, repr(value)))

def generate_secret_key():
    # Based on: http://techblog.leosoto.com/django-secretkey-generation/
    chars = string.digits + string.letters + string.punctuation
    return u''.join(random.SystemRandom().choice(chars) for i in range(100))


if __name__ == u'__main__':
    with Configure() as configure, Settings() as settings:

        # Django Secret Key generated only if not stored in the configuration, yet.
        secret_key = configure.auto(u'secret_key', generate_secret_key())
        settings.setting(u'SECRET_KEY', secret_key)

        # Social accounts Client IDs and Secrets
        print(dedent(u"""
                Enter your OAuth Client IDs and Secrets for social account providers. If you
                don't want to use some providers, just skip them by entering empty strings.
                Don't share the keys with anybody and never push them to git."""))
        with JsonFile(u'fixtures/socialaccount_socialapp.json.tpl', u'fixtures/socialaccount_socialapp.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'socialaccount.socialapp':
                    client_id = configure.input(u'%s_client_id' % entry[u'fields'][u'provider'], u'%s Client ID' % entry[u'fields'][u'name'])
                    secret = configure.input(u'%s_secret' % entry[u'fields'][u'provider'], u'%s Secret' % entry[u'fields'][u'name'])
                    entry[u'fields'][u'client_id'] = client_id
                    entry[u'fields'][u'secret'] = secret

        # Obligee dummy mails
        print(dedent(u"""
                To prevent unsolicited emails to obligees while testing we replace their
                addresses with dummies. Use '{name}' as a placeholder to distinguish individual
                obligees. For instance 'mail@{name}.example.com' may be expanded to
                'mail@martika-hnusta.example.com'."""))
        mail_tpl = configure.input(u'obligee_dummy_mail', u'Obligee dummy e-mail', required=True)
        with JsonFile(u'fixtures/obligees_obligee.json.tpl', u'fixtures/obligees_obligee.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'obligees.obligee':
                    slug = entry[u'fields'][u'slug'].strip(u'-')
                    mail = mail_tpl.format(name=slug)
                    entry[u'fields'][u'email'] = mail

        # Dummymail or Mandrill testing mode
        print(dedent(u"""
                Local testing has two modes. The first mode, Dummymail, does not send any real
                emails. It just mocks local SMPT/IMAP servers and does not support any advanced
                features like message bounces. The second mode uses Madrill transactional mail
                service to send the emails. If you want to use Mandrill, you will need to
                supply a Mandrill API key. If using Mandrill while testing, make sure you don't
                send any unsolicited emails to real addresses. You should configure your
                Mandrill API key to be in testing mode, or make sure you only send emails to
                addresses you control."""))
        testing_mode = configure.input_choice(u'testing_mode', u'Testing mode', choices=(
                (u'dummymail', u'Dummymail with local mocked SMPT/IMAP servers.'),
                (u'mandrill', u'Using Madrill transactional mail service.'),
                ))
        settings.include(u'dummymail.py' if testing_mode == u'dummymail' else u'mandrill.py')

        # Mandrill API key
        if testing_mode == u'mandrill':
            mandrill_api_key = configure.input(u'mandrill_api_key', u'Mandrill API key', required=True)
            settings.setting(u'MANDRILL_API_KEY', mandrill_api_key)
