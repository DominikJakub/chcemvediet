# vim: expandtab
# -*- coding: utf-8 -*-
import os
import json
import re
import string
import random
from textwrap import dedent
from getpass import getpass

class JsonFile(object):
    def __init__(self, inputfile, outputfile=None):
        self.inputfile = inputfile
        self.outputfile = outputfile or inputfile
        with open(inputfile) as json_file:
            self.data = json.load(json_file)

    def __enter__(self):
        return self.data

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.outputfile, u'w') as json_file:
                json.dump(self.data, json_file, indent=2)

class Configure(object):
    def __init__(self, filename=u'configure.json'):
        self.filename = filename
        try:
            with open(filename) as json_file:
                self.data = json.load(json_file)
        except IOError:
            self.data = {}

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as json_file:
                json.dump(self.data, json_file, indent=2, sort_keys=True)

    def auto(self, key, default):
        return self.data.setdefault(key, default)

    def input(self, key, prompt, default=u'', required=False):
        configured = self.data.get(key, default)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured)) or configured
            if required and not inputed:
                print(u'\nError: The value is required.')
                continue
            break
        self.data[key] = inputed
        return inputed

    def input_password(self, key, prompt, hasher, required=False):
        configured = self.data.get(key, u'')
        while True:
            inputed = getpass(u'\n%s [%s]: ' % (prompt, u'*****' if configured else u''))
            if required and not inputed and not configured:
                print(u'\nError: The value is required.')
                continue
            break
        hashed = hasher(inputed) if inputed else configured
        self.data[key] = hashed
        return hashed

    def input_choice(self, key, prompt, choices, default=u''):
        configured = self.data.get(key, default)
        configured_choice = u''
        print(u'\n%s:' % prompt)
        for idx, (value, label) in enumerate(choices):
            print(u' %d) %s' % (idx+1, label))
            if value == configured:
                configured_choice = u'%d' % (idx+1)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured_choice)) or configured_choice
            if not inputed:
                print(u'\nError: The value is required.')
                continue
            try:
                value, label = choices[int(inputed)-1]
            except (ValueError, IndexError):
                print(u'\nError: Invalid choice.')
                continue
            break
        self.data[key] = value
        return value

class Settings(object):
    def __init__(self, filename=u'chcemvediet/settings/configured.py'):
        self.filename = filename
        self.lines = []
        self.comment(u'This file was autogenerated by `configure.py`. Do NOT edit it.')

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as settings_file:
                settings_file.write(u'\n'.join(self.lines) + u'\n')

    def comment(self, text):
        for line in text.split(u'\n'):
            self.lines.append(u'# %s' % line)

    def include(self, filaname):
        self.lines.append(u'execfile(os.path.join(SETTINGS_PATH, %s))' % repr(filaname))

    def setting(self, name, value):
        self.lines.append(u'%s = %s' % (name, repr(value)))

def generate_secret_key(length, chars):
    sysrandom = random.SystemRandom()
    return u''.join(sysrandom.choice(chars) for i in range(length))


if __name__ == u'__main__':
    with Configure() as configure, Settings() as settings:

        # Django Secret Key generated only if not stored in the configuration, yet.
        secret_key = configure.auto(u'secret_key', generate_secret_key(100, string.digits + string.letters + string.punctuation))
        settings.setting(u'SECRET_KEY', secret_key)

        # Social accounts Client IDs and Secrets
        print(dedent(u"""
                Enter your OAuth Client IDs and Secrets for social account providers. If you
                don't want to use some providers, just skip them by entering empty strings.
                Don't share the keys with anybody and never push them to git."""))
        with JsonFile(u'fixtures/socialaccount_socialapp.json.tpl', u'fixtures/socialaccount_socialapp.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'socialaccount.socialapp':
                    client_id = configure.input(u'%s_client_id' % entry[u'fields'][u'provider'], u'%s Client ID' % entry[u'fields'][u'name'])
                    secret = configure.input(u'%s_secret' % entry[u'fields'][u'provider'], u'%s Secret' % entry[u'fields'][u'name'])
                    entry[u'fields'][u'client_id'] = client_id
                    entry[u'fields'][u'secret'] = secret

        # Obligee dummy mails
        print(dedent(u"""
                To prevent unsolicited emails to obligees while testing we replace their
                addresses with dummies. Use '{name}' as a placeholder to distinguish individual
                obligees. For instance 'mail@{name}.example.com' may be expanded to
                'mail@martika-hnusta.example.com'."""))
        mail_tpl = configure.input(u'obligee_dummy_mail', u'Obligee dummy e-mail', required=True)
        with JsonFile(u'fixtures/obligees_obligee.json.tpl', u'fixtures/obligees_obligee.configured.json') as data:
            for entry in data:
                if entry[u'model'] in [u'obligees.obligee', u'obligees.historicalobligee']:
                    slug = entry[u'fields'][u'slug'].strip(u'-')
                    mail = mail_tpl.format(name=slug)
                    entry[u'fields'][u'emails'] = mail

        # Server email addresses
        print(dedent(u"""
                Set admin e-mail, inforequest unique e-mail template and default from address.
                The admin e-mail will be used for lowlevel error reporting and administration
                e-mails. Inforequest unique e-mail template will be used to generate unique from
                e-mail addresses used by inforequests. The unique e-mail template must contain
                '{token}' as a placeholdel to distinguish individual inforequests. For instance
                '{token}@mail.example.com' may be expanded to 'lama@mail.example.com'. The
                default from address will be used as the from e-mail addresses for all other
                e-mails. All these e-mail should be on a domain you control."""))
        admin_email = configure.input(u'admin_email', u'Admin e-mail', default=u'admin@chcemvediet.sk', required=True)
        default_from_email = configure.input(u'default_from_email', u'Default from e-mail', default=u'info@chcemvediet.sk', required=True)
        inforequest_unique_email = configure.input(u'inforequest_unique_email', u'Inforequest unique e-mail', default=u'{token}@mail.chcemvediet.sk', required=True)
        settings.setting(u'SERVER_EMAIL', admin_email)
        settings.setting(u'DEFAULT_FROM_EMAIL', default_from_email)
        settings.setting(u'INFOREQUEST_UNIQUE_EMAIL', inforequest_unique_email)
        settings.setting(u'ADMINS[len(ADMINS):]', [(u'Admin', admin_email)])

        # Dummymail or Mandrill testing mode
        print(dedent(u"""
                Local testing has three modes:

                 -- Madrill:
                        Madrill is a transactional mail service we use to send emails. If you want
                        to use Mandrill for testing, you will need to supply Mandrill API key and
                        other details. If using Mandrill while testing, make sure you don't send
                        any unsolicited emails to real addresses. You should configure your
                        Mandrill API key to be in testing mode, or make sure you only send emails
                        to addresses you control.

                 -- Dummymail:
                        Dummymail does not send any real emails, it just mocks local SMPT/IMAP
                        servers. This mode does not support any advanced features like message
                        bounces. You can use any local SMTP/IMAP client to read emails sent by the
                        application and send your replies back to the application.

                 -- No mail:
                        The last mode does not send any emails at all, it just stores them in the
                        database. You can use admin interface to emails sent from the application,
                        or to manually mock replies to them."""))
        testing_mode = configure.input_choice(u'testing_mode', u'Testing mode', choices=(
                (u'mandrill', u'Using Madrill transactional mail service.'),
                (u'dummymail', u'Dummymail with local mocked SMPT/IMAP servers.'),
                (u'no-mail', u'No mail infrastructure at all.'),
                ))
        if testing_mode == u'mandrill':
            settings.include(u'mandrill.py')
        elif testing_mode == u'dummymail':
            settings.include(u'dummymail.py')
        else: # testing_mode == u'no-mail'
            settings.include(u'nomail.py')

        # Mandrill API key and Webhook configuration
        if testing_mode == u'mandrill':
            mandrill_api_key = configure.input(u'mandrill_api_key', u'Mandrill API key', required=True)
            settings.setting(u'MANDRILL_API_KEY', mandrill_api_key)

            print(dedent(u"""
                    To setup Mandrill webhook you need an URL Mandrill server can access. If you are
                    running your server behing a firewall or NAT, you need to setup a tunelling
                    reverse proxy to your localhost. See https://ngrok.com/ for instance. Please
                    enter your webhook URL prefix. If using ngrok, your prefix should look like
                    "https://<yoursubdomain>.ngrok.com/". If you don't want to setup Mandrill
                    webhook, just leave it empty."""))
            mandrill_webhook_prefix = configure.input(u'mandrill_webhook_prefix', u'Mandrill Webhook Prefix')
            if mandrill_webhook_prefix:
                mandrill_webhook_secret = configure.auto(u'mandrill_webhook_secret', generate_secret_key(32, string.digits + string.letters))
                mandrill_webhook_url = u'%s/mandrill/webhook/?secret=%s' % (mandrill_webhook_prefix.rstrip(u'/'), mandrill_webhook_secret)
                settings.setting(u'MANDRILL_WEBHOOK_SECRET', mandrill_webhook_secret)
                settings.setting(u'MANDRILL_WEBHOOK_URL', mandrill_webhook_url)

                print(dedent(u"""
                        After you finish this configuration and run your server, you can open Mandrill
                        webhook settings and create a webhook with the following URL:

                            %s

                        It is not possible to create the webhook before you run your server, because
                        Mandrill checks if the given URL works. After you create your webhooks, run this
                        configuration once again and enter all their keys as given by Mandrill. If you
                        are entering multiple webhook keys, separate them with space. Leave the key
                        empty if you have not created the webhook yet."""
                        % mandrill_webhook_url))
                mandrill_webhook_keys = configure.input(u'mandrill_webhook_keys', u'Mandrill webhook keys')
                settings.setting(u'MANDRILL_WEBHOOK_KEYS', mandrill_webhook_keys.split())

    # Settings module is configured and we may use django now.
    os.environ.setdefault(u'DJANGO_SETTINGS_MODULE', u'chcemvediet.settings')

    with Configure() as configure:
        from django.contrib.auth.hashers import make_password

        # Admin e-mail and password
        print(dedent(u"""
                Enter site admin password."""))
        admin_password = configure.input_password(u'admin_password', u'Admin password', make_password, required=True)
        with JsonFile(u'fixtures/auth_user.json.tpl', u'fixtures/auth_user.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'auth.user' and entry[u'fields'][u'username'] == u'admin':
                    entry[u'fields'][u'email'] = admin_email # Obtained earlier
                    entry[u'fields'][u'password'] = admin_password
