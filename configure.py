# vim: expandtab
# -*- coding: utf-8 -*-
import os
import json
import re
import string
import random
from textwrap import dedent
from getpass import getpass

class JsonFile(object):
    def __init__(self, inputfile, outputfile=None):
        self.inputfile = inputfile
        self.outputfile = outputfile or inputfile
        with open(inputfile) as json_file:
            self.data = json.load(json_file)

    def __enter__(self):
        return self.data

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.outputfile, u'w') as json_file:
                json.dump(self.data, json_file, indent=2)

class Configure(object):
    def __init__(self, filename=u'configure.json'):
        self.filename = filename
        try:
            with open(filename) as json_file:
                self.data = json.load(json_file)
        except IOError:
            self.data = {}

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as json_file:
                json.dump(self.data, json_file, indent=2, sort_keys=True)

    def auto(self, key, default):
        return self.data.setdefault(key, default)

    def input(self, key, prompt, default=u'', required=False):
        configured = self.data.get(key, default)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured)) or configured
            if required and not inputed:
                print(u'\nError: The value is required.')
                continue
            break
        self.data[key] = inputed
        return inputed

    def input_password(self, key, prompt, hasher, required=False):
        configured = self.data.get(key, u'')
        while True:
            inputed = getpass(u'\n%s [%s]: ' % (prompt, u'*****' if configured else u''))
            if required and not inputed and not configured:
                print(u'\nError: The value is required.')
                continue
            break
        hashed = hasher(inputed) if inputed else configured
        self.data[key] = hashed
        return hashed

    def input_choice(self, key, prompt, choices, default=u''):
        configured = self.data.get(key, default)
        configured_choice = u''
        print(u'\n%s:' % prompt)
        for idx, (value, label) in enumerate(choices):
            print(u' %d) %s' % (idx+1, label))
            if value == configured:
                configured_choice = u'%d' % (idx+1)
        while True:
            inputed = raw_input(u'\n%s [%s]: ' % (prompt, configured_choice)) or configured_choice
            if not inputed:
                print(u'\nError: The value is required.')
                continue
            try:
                value, label = choices[int(inputed)-1]
            except (ValueError, IndexError):
                print(u'\nError: Invalid choice.')
                continue
            break
        self.data[key] = value
        return value

class Settings(object):
    def __init__(self, filename=u'chcemvediet/settings/configured.py'):
        self.filename = filename
        self.lines = []
        self.comment(u'This file was autogenerated by `configure.py`. Do NOT edit it.')

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            with open(self.filename, u'w') as settings_file:
                settings_file.write(u'\n'.join(self.lines) + u'\n')

    def comment(self, text):
        for line in text.split(u'\n'):
            self.lines.append(u'# %s' % line)

    def include(self, filaname):
        self.lines.append(u'execfile(os.path.join(SETTINGS_PATH, %s))' % repr(filaname))

    def setting(self, name, value):
        self.lines.append(u'%s = %s' % (name, repr(value)))

def generate_secret_key(length, chars):
    return u''.join(random.SystemRandom().choice(chars) for i in range(length))


if __name__ == u'__main__':
    with Configure() as configure, Settings() as settings:

        # Django Secret Key generated only if not stored in the configuration, yet.
        secret_key = configure.auto(u'secret_key', generate_secret_key(100, string.digits + string.letters + string.punctuation))
        settings.setting(u'SECRET_KEY', secret_key)

        # Social accounts Client IDs and Secrets
        print(dedent(u"""
                Enter your OAuth Client IDs and Secrets for social account providers. If you
                don't want to use some providers, just skip them by entering empty strings.
                Don't share the keys with anybody and never push them to git."""))
        with JsonFile(u'fixtures/socialaccount_socialapp.json.tpl', u'fixtures/socialaccount_socialapp.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'socialaccount.socialapp':
                    client_id = configure.input(u'%s_client_id' % entry[u'fields'][u'provider'], u'%s Client ID' % entry[u'fields'][u'name'])
                    secret = configure.input(u'%s_secret' % entry[u'fields'][u'provider'], u'%s Secret' % entry[u'fields'][u'name'])
                    entry[u'fields'][u'client_id'] = client_id
                    entry[u'fields'][u'secret'] = secret

        # Obligee dummy mails
        print(dedent(u"""
                To prevent unsolicited emails to obligees while testing we replace their
                addresses with dummies. Use '{name}' as a placeholder to distinguish individual
                obligees. For instance 'mail@{name}.example.com' may be expanded to
                'mail@martika-hnusta.example.com'."""))
        mail_tpl = configure.input(u'obligee_dummy_mail', u'Obligee dummy e-mail', required=True)
        with JsonFile(u'fixtures/obligees_obligee.json.tpl', u'fixtures/obligees_obligee.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'obligees.obligee':
                    slug = entry[u'fields'][u'slug'].strip(u'-')
                    mail = mail_tpl.format(name=slug)
                    entry[u'fields'][u'email'] = mail

        # Dummymail or Mandrill testing mode
        print(dedent(u"""
                Local testing has two modes. The first mode, Dummymail, does not send any real
                emails. It just mocks local SMPT/IMAP servers and does not support any advanced
                features like message bounces. The second mode uses Madrill transactional mail
                service to send the emails. If you want to use Mandrill, you will need to supply
                Mandrill API key and other details. If using Mandrill while testing, make sure
                you don't send any unsolicited emails to real addresses. You should configure
                your Mandrill API key to be in testing mode, or make sure you only send emails
                to addresses you control."""))
        testing_mode = configure.input_choice(u'testing_mode', u'Testing mode', choices=(
                (u'dummymail', u'Dummymail with local mocked SMPT/IMAP servers.'),
                (u'mandrill', u'Using Madrill transactional mail service.'),
                ))
        settings.include(u'dummymail.py' if testing_mode == u'dummymail' else u'mandrill.py')

        # Mandrill API key and Webhook configuration
        if testing_mode == u'mandrill':
            mandrill_api_key = configure.input(u'mandrill_api_key', u'Mandrill API key', required=True)
            settings.setting(u'MANDRILL_API_KEY', mandrill_api_key)

            print(dedent(u"""
                    To setup Mandrill webhook you need an URL Mandrill server can access. If you are
                    running your server behing a firewall or NAT, you need to setup a tunelling
                    reverse proxy to your localhost. See https://ngrok.com/ for instance. Please
                    enter your webhook URL prefix. If using ngrok, your prefix should look like
                    "https://<yoursubdomain>.ngrok.com/". If you don't want to setup Mandrill
                    webhook, just leave it empty."""))
            mandrill_webhook_prefix = configure.input(u'mandrill_webhook_prefix', u'Mandrill Webhook Prefix')
            if mandrill_webhook_prefix:
                mandrill_webhook_secret = configure.auto(u'mandrill_webhook_secret', generate_secret_key(32, string.digits + string.letters))
                mandrill_webhook_url = u'%s/mandrill/webhook/?secret=%s' % (mandrill_webhook_prefix.rstrip(u'/'), mandrill_webhook_secret)
                settings.setting(u'MANDRILL_WEBHOOK_SECRET', mandrill_webhook_secret)
                settings.setting(u'MANDRILL_WEBHOOK_URL', mandrill_webhook_url)

                print(dedent(u"""
                        After you finish this configuration and run your server, you can open Mandrill
                        webhook settings and create a webhook with the following URL:

                            %s

                        It is not possible to create the webhook before you run your server, because
                        Mandrill checks if the given URL works. After you create your webhook, run this
                        configuration once again and enter the its key as given by Mandrill. Leave the
                        key empty if you have not created the webhook yet."""
                        % mandrill_webhook_url))
                mandrill_webhook_key = configure.input(u'mandrill_webhook_key', u'Mandrill webhook key')
                settings.setting(u'MANDRILL_WEBHOOK_KEY', mandrill_webhook_key)

    # Settings module is configured and we may use django now.
    os.environ.setdefault(u'DJANGO_SETTINGS_MODULE', u'chcemvediet.settings')

    with Configure() as configure:
        from django.contrib.auth.hashers import make_password

        # Admin e-mail and password
        print(dedent(u"""
                Enter site admin email and password."""))
        admin_email = configure.input(u'admin_email', u'Admin e-mail', required=True)
        admin_password = configure.input_password(u'admin_password', u'Admin password', make_password, required=True)
        with JsonFile(u'fixtures/auth_user.json.tpl', u'fixtures/auth_user.configured.json') as data:
            for entry in data:
                if entry[u'model'] == u'auth.user' and entry[u'fields'][u'username'] == u'admin':
                    entry[u'fields'][u'email'] = admin_email
                    entry[u'fields'][u'password'] = admin_password
