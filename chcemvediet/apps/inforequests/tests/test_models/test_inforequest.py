# vim: expandtab
# -*- coding: utf-8 -*-
import datetime
import random
import mock

from django.core.urlresolvers import reverse
from django.db import IntegrityError
from django.contrib.auth.models import User
from django.utils import timezone
from django.test import TestCase

from poleno.timewarp import timewarp
from poleno.mail.models import Message
from poleno.utils.date import local_datetime_from_local, local_datetime_from_utc, utc_now, naive_date
from poleno.utils.test import created_instances

from .. import InforequestsTestCaseMixin
from ...models import Inforequest, InforequestEmail, Paperwork, Action, ActionDraft

class InforequestTest(InforequestsTestCaseMixin, TestCase):
    u"""
    Tests ``Inforequest`` model.
    """

    def test_applicant_field(self):
        inforequest = self._create_inforequest(applicant=self.user1)
        self.assertEqual(inforequest.applicant, self.user1)

    def test_applicant_field_may_not_be_null(self):
        with self.assertRaisesMessage(AssertionError, u'Inforequest.applicant is mandatory'):
            self._create_inforequest(omit=[u'applicant'])

    def test_email_set_relation(self):
        inforequest = self._create_inforequest()
        email1, rel1 = self._create_inforequest_email(inforequest=inforequest)
        email2, rel2 = self._create_inforequest_email(inforequest=inforequest)
        result = inforequest.email_set.all()
        self.assertItemsEqual(result, [email1, email2])

    def test_email_set_relation_empty_by_default(self):
        inforequest = self._create_inforequest()
        result = inforequest.email_set.all()
        self.assertItemsEqual(result, [])

    def test_applicant_name_street_city_and_zip_fields_are_autogenerated_when_creating_new_instance(self):
        user = self._create_user(first_name=u'John', last_name=u'Smith', street=u'123 Westside', city=u'Winterfield', zip=u'12345')
        inforequest = self._create_inforequest(applicant=user)
        self.assertEqual(inforequest.applicant_name, u'John Smith')
        self.assertEqual(inforequest.applicant_street, u'123 Westside')
        self.assertEqual(inforequest.applicant_city, u'Winterfield')
        self.assertEqual(inforequest.applicant_zip, u'12345')

    def test_applicant_name_street_city_and_zip_fields_are_not_regenerated_when_saving_existing_instance(self):
        user = self._create_user(first_name=u'John', last_name=u'Smith', street=u'123 Westside', city=u'Winterfield', zip=u'12345')
        inforequest = self._create_inforequest(applicant=user)
        user.first_name = u'Changed'
        user.last_name = u'Changed'
        user.save()
        user.profile.street = u'Changed'
        user.profile.city = u'Changed'
        user.profile.zip = u'11111'
        user.profile.save()
        inforequest.closed = True
        inforequest.save()
        inforequest = Inforequest.objects.get(pk=inforequest.pk)
        self.assertEqual(inforequest.applicant_name, u'John Smith')
        self.assertEqual(inforequest.applicant_street, u'123 Westside')
        self.assertEqual(inforequest.applicant_city, u'Winterfield')
        self.assertEqual(inforequest.applicant_zip, u'12345')

    def test_applicant_name_street_city_and_zip_fields_may_not_be_set_explicitly(self):
        with self.assertRaisesMessage(AssertionError, u'Inforequest.applicant_name is read-only'):
            self._create_inforequest(applicant_name=u'Name')
        with self.assertRaisesMessage(AssertionError, u'Inforequest.applicant_street is read-only'):
            self._create_inforequest(applicant_street=u'Street')
        with self.assertRaisesMessage(AssertionError, u'Inforequest.applicant_city is read-only'):
            self._create_inforequest(applicant_city=u'City')
        with self.assertRaisesMessage(AssertionError, u'Inforequest.applicant_zip is read-only'):
            self._create_inforequest(applicant_zip=u'00000')

    def test_unique_email_field_is_autogenerated_when_creating_new_instance(self):
        inforequest = self._create_inforequest()
        self.assertRegexpMatches(inforequest.unique_email, r'^.+@.+\..+$')

    def test_unique_email_field_is_not_regenerated_when_saving_existing_instance(self):
        inforequest = self._create_inforequest()
        old_unique_email = inforequest.unique_email
        inforequest.closed = True
        inforequest.save()
        inforequest = Inforequest.objects.get(pk=inforequest.pk)
        self.assertEqual(inforequest.unique_email, old_unique_email)

    def test_unique_email_field_autogenerated_values_are_unique(self):
        u"""
        Generate 100 inforequests and check that all generated emails are unique.
        """
        inforequests = [self._create_inforequest() for i in range(100)]
        emails = [ir.unique_email for ir in inforequests]
        self.assertEqual(len(set(emails)), 100)

    def test_unique_email_field_handling_collisions(self):
        with self.settings(INFOREQUEST_UNIQUE_EMAIL=u'{token}@example.com'):
            with mock.patch(u'chcemvediet.apps.inforequests.models.random_readable_string') as mock_random:
                mock_random.side_effect = [u'bbbb', u'bbbb', u'bbbb', u'bbbb', u'cccc']
                inforequest1 = self._create_inforequest()
                inforequest2 = self._create_inforequest()
                self.assertEqual(inforequest1.unique_email, u'bbbb@example.com')
                self.assertEqual(inforequest2.unique_email, u'cccc@example.com')

    def test_unique_email_field_with_too_many_collisions(self):
        with mock.patch(u'chcemvediet.apps.inforequests.models.random_readable_string') as mock_random:
            mock_random.return_value = u'bbbb'
            inforequest1 = self._create_inforequest()
            mock_random.reset_mock()
            with self.assertRaisesMessage(IntegrityError, u'column unique_email is not unique'):
                inforequest2 = self._create_inforequest()
            self.assertEqual(mock_random.mock_calls, [mock.call(i) for i in range(4,11)])

    def test_unique_email_field_may_not_be_set_explicitly(self):
        with self.assertRaisesMessage(AssertionError, u'Inforequest.unique_email is read-only'):
            inforequest = self._create_inforequest(unique_email=u'something@example.com')

    def test_submission_date_field_is_autogenerated_when_creating_new_instance(self):
        timewarp.jump(local_datetime_from_local(u'2014-10-05 10:33:00'))
        inforequest = self._create_inforequest()
        self.assertEqual(inforequest.submission_date, naive_date(u'2014-10-05'))

    def test_submission_date_field_autogenerated_value_is_in_local_timezone(self):
        u"""
        Checks that if local date is different than UTC date, local date is used.
        """
        with timezone.override(u'Europe/Bratislava'): # UTC +1
            timewarp.jump(local_datetime_from_utc(u'2014-10-05 23:33:00'))
            inforequest = self._create_inforequest()
            self.assertEqual(inforequest.submission_date, naive_date(u'2014-10-06'))

    def test_submission_date_field_is_not_regenerated_when_saving_existing_instance(self):
        timewarp.jump(local_datetime_from_local(u'2014-10-05 10:33:00'))
        inforequest = self._create_inforequest()
        timewarp.jump(local_datetime_from_local(u'2014-10-17 11:20:00'))
        inforequest.closed = True
        inforequest.save()
        inforequest = Inforequest.objects.get(pk=inforequest.pk)
        self.assertEqual(inforequest.submission_date, naive_date(u'2014-10-05'))

    def test_closed_field(self):
        inforequest = self._create_inforequest(closed=True)
        self.assertTrue(inforequest.closed)

    def test_closed_field_default_value_if_omitted(self):
        inforequest = self._create_inforequest(omit=[u'closed'])
        self.assertFalse(inforequest.closed)

    def test_last_undecided_email_reminder_field(self):
        dt = local_datetime_from_local(u'2014-10-05 10:33:00')
        inforequest = self._create_inforequest(last_undecided_email_reminder=dt)
        self.assertEqual(inforequest.last_undecided_email_reminder, dt)

    def test_last_undecided_email_reminder_field_default_value_if_omitted(self):
        inforequest = self._create_inforequest(omit=[u'last_undecided_email_reminder'])
        self.assertIsNone(inforequest.last_undecided_email_reminder)

    def test_paperwork_set_relation(self):
        inforequest, paperwork, _ = self._create_inforequest_scenario()
        result = inforequest.paperwork_set.all()
        self.assertItemsEqual(result, [paperwork])

    def test_paperwork_set_relation_with_advancement(self):
        inforequest, paperwork1, actions = self._create_inforequest_scenario(u'advancement')
        _, (_, ((paperwork2, _),)) = actions
        result = inforequest.paperwork_set.all()
        self.assertItemsEqual(result, [paperwork1, paperwork2])

    def test_paperwork_set_relation_empty_by_default(self):
        inforequest = self._create_inforequest()
        result = inforequest.paperwork_set.all()
        self.assertItemsEqual(result, [])

    def test_actiondraft_set_relation(self):
        inforequest, _, _ = self._create_inforequest_scenario()
        draft1 = self._create_action_draft(inforequest=inforequest, type=ActionDraft.TYPES.CONFIRMATION)
        draft2 = self._create_action_draft(inforequest=inforequest, type=ActionDraft.TYPES.EXTENSION)
        result = inforequest.actiondraft_set.all()
        self.assertItemsEqual(result, [draft1, draft2])

    def test_actiondraft_set_relation_empty_by_default(self):
        inforequest, _, _ = self._create_inforequest_scenario()
        result = inforequest.actiondraft_set.all()
        self.assertItemsEqual(result, [])

    def test_inforequestemail_set_relation(self):
        inforequest = self._create_inforequest()
        email1, rel1 = self._create_inforequest_email(inforequest=inforequest)
        email2, rel2 = self._create_inforequest_email(inforequest=inforequest)
        result = inforequest.inforequestemail_set.all()
        self.assertItemsEqual(result, [rel1, rel2])

    def test_inforequestemail_set_relation_empty_by_default(self):
        inforequest = self._create_inforequest()
        result = inforequest.inforequestemail_set.all()
        self.assertItemsEqual(result, [])

    def test_user_inforequest_set_backward_relation(self):
        inforequest1 = self._create_inforequest(applicant=self.user1)
        inforequest2 = self._create_inforequest(applicant=self.user1)
        result = self.user1.inforequest_set.all()
        self.assertItemsEqual(result, [inforequest1, inforequest2])

    def test_user_inforequest_set_backward_relation_empty_by_default(self):
        result = self.user1.inforequest_set.all()
        self.assertItemsEqual(result, [])

    def test_message_inforequest_set_backward_relation(self):
        inforequest = self._create_inforequest()
        email, rel = self._create_inforequest_email(inforequest=inforequest)
        result = email.inforequest_set.all()
        self.assertItemsEqual(result, [inforequest])

    def test_message_inforequest_set_backward_relation_empty_by_default(self):
        email = self._create_message()
        result = email.inforequest_set.all()
        self.assertItemsEqual(result, [])

    def test_default_ordering_by_submission_date_then_pk(self):
        dates = [
                u'2014-10-04',
                u'2014-10-05',
                u'2014-10-06', # Several with the same date, to check secondary ordering
                u'2014-10-06',
                u'2014-10-06',
                u'2014-10-06',
                u'2014-10-06',
                u'2014-11-05',
                u'2015-10-05',
                ]
        random.shuffle(dates)
        inforequests = []
        for date in dates:
            timewarp.jump(local_datetime_from_local(u'%s 10:33:00' % date))
            inforequests.append(self._create_inforequest())
        result = Inforequest.objects.all()
        self.assertEqual(list(result), sorted(inforequests, key=lambda ir: (ir.submission_date, ir.pk)))

    def test_paperwork_property(self):
        inforequest, paperwork, _ = self._create_inforequest_scenario()
        self.assertEqual(inforequest.paperwork, paperwork)

    def test_paperwork_property_with_advancement(self):
        inforequest, paperwork1, actions = self._create_inforequest_scenario(u'advancement')
        _, (_, ((paperwork2, _),)) = actions
        self.assertEqual(inforequest.paperwork, paperwork1)

    def test_paperwork_property_raises_exception_if_inforequest_has_no_paperwork(self):
        inforequest = self._create_inforequest()
        with self.assertRaisesMessage(Paperwork.DoesNotExist, u'Paperwork matching query does not exist.'):
            inforequest.paperwork

    def test_undecided_set_property_and_friends(self):
        u"""
        Tests ``undecided_set`` property and properties ``has_undecided_email``,
        ``oldest_undecided_email`` and ``newest_undecided_email`` using it.
        """
        inforequest, _, _ = self._create_inforequest_scenario()
        email1, rel1 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNKNOWN)
        email2, rel2 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNRELATED)
        email3, rel3 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNDECIDED)
        email4, rel4 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.APPLICANT_ACTION)
        email5, rel5 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.OBLIGEE_ACTION)
        email6, rel6 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNDECIDED)
        self.assertTrue(inforequest.has_undecided_email)
        self.assertEqual(inforequest.oldest_undecided_email, email3)
        self.assertEqual(inforequest.newest_undecided_email, email6)
        self.assertItemsEqual(inforequest.undecided_set.all(), [email3, email6])

    def test_undecided_set_property_and_friends_with_no_undecided_emails(self):
        inforequest, _, _ = self._create_inforequest_scenario()
        email1, rel1 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNKNOWN)
        email2, rel2 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNRELATED)
        email4, rel4 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.APPLICANT_ACTION)
        email5, rel5 = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.OBLIGEE_ACTION)
        self.assertFalse(inforequest.has_undecided_email)
        self.assertIsNone(inforequest.oldest_undecided_email)
        self.assertIsNone(inforequest.newest_undecided_email)
        self.assertItemsEqual(inforequest.undecided_set.all(), [])

    def test_can_add_x_properties_with_one_paperwork(self):
        inforequest, _, _ = self._create_inforequest_scenario()
        # ``paperwork`` last action is ``REQUEST``
        self.assertFalse(inforequest.can_add_clarification_response)
        self.assertFalse(inforequest.can_add_appeal)
        self.assertTrue(inforequest.can_add_confirmation)
        self.assertTrue(inforequest.can_add_extension)
        self.assertTrue(inforequest.can_add_advancement)
        self.assertTrue(inforequest.can_add_clarification_request)
        self.assertTrue(inforequest.can_add_disclosure)
        self.assertTrue(inforequest.can_add_refusal)
        self.assertFalse(inforequest.can_add_affirmation)
        self.assertFalse(inforequest.can_add_reversion)
        self.assertFalse(inforequest.can_add_remandment)

    def test_can_add_x_properties_with_multiple_paperworks(self):
        u"""
        Checks that the set of actions allowed for an inforequest is the union of sets of actions
        allowed for its paperworks.
        """
        inforequest, _, _ = self._create_inforequest_scenario((u'advancement',
            [u'refusal', u'appeal', u'remandment'],
            [u'clarification_request'],
            [(u'advancement',
                [u'confirmation'],
                )],
            ))
        # The main paperwork last action is ``ADVANCEMENT``. The main paperwork adcanced to other
        # three paperworks ending with ``EXTENSION`` and ``CLARIFICATION_REQUEST`` and
        # ``ADVANCEMENT``, respectivelly. The latter advancement advanced to yet another paperwork
        # ending with ``CONFIRMATION``.
        self.assertTrue(inforequest.can_add_clarification_response) # from ``CLARIFICATION_REQUEST``
        self.assertTrue(inforequest.can_add_appeal)                 # from ``ADVANCEMENT``
        self.assertFalse(inforequest.can_add_confirmation)
        self.assertTrue(inforequest.can_add_extension)              # from ``REMANDMENT`` and ``CONFIRMATION``
        self.assertTrue(inforequest.can_add_advancement)            # from ``CONFIRMATION``
        self.assertTrue(inforequest.can_add_clarification_request)  # from ``CLARIFICATION_REQUEST`` and ``CONFIRMATION``
        self.assertTrue(inforequest.can_add_disclosure)             # from ``REMANDMENT`` and ``CONFIRMATION``
        self.assertTrue(inforequest.can_add_refusal)                # from ``REMANDMENT`` and ``CONFIRMATION``
        self.assertFalse(inforequest.can_add_affirmation)
        self.assertFalse(inforequest.can_add_reversion)
        self.assertFalse(inforequest.can_add_remandment)

    def test_can_add_action_method(self):
        tests = (                                   # expected result
                (Action.TYPES.REQUEST,                AttributeError, u"'Paperwork' object has no attribute 'can_add_request'"),
                (Action.TYPES.CLARIFICATION_RESPONSE, False,          None),
                (Action.TYPES.APPEAL,                 False,          None),
                (Action.TYPES.CONFIRMATION,           True,           None),
                (Action.TYPES.EXTENSION,              True,           None),
                (Action.TYPES.ADVANCEMENT,            True,           None),
                (Action.TYPES.CLARIFICATION_REQUEST,  True,           None),
                (Action.TYPES.DISCLOSURE,             True,           None),
                (Action.TYPES.REFUSAL,                True,           None),
                (Action.TYPES.AFFIRMATION,            False,          None),
                (Action.TYPES.REVERSION,              False,          None),
                (Action.TYPES.REMANDMENT,             False,          None),
                (Action.TYPES.ADVANCED_REQUEST,       AttributeError, u"'Paperwork' object has no attribute 'can_add_advanced_request'"),
                (Action.TYPES.EXPIRATION,             AttributeError, u"'Paperwork' object has no attribute 'can_add_expiration'"),
                (Action.TYPES.APPEAL_EXPIRATION,      AttributeError, u"'Paperwork' object has no attribute 'can_add_appeal_expiration'"),
                )
        # Make sure we are testing all defined action types
        tested_action_types = set(a for a, _, _ in tests)
        defined_action_types = Action.TYPES._inverse.keys()
        self.assertItemsEqual(tested_action_types, defined_action_types)

        # ``paperwork`` last action is ``REQUEST``
        inforequest, _, _ = self._create_inforequest_scenario()
        for action_type, expected_result, expected_message in tests:
            if expected_result is True:
                self.assertTrue(inforequest.can_add_action(action_type))
            elif expected_result is False:
                self.assertFalse(inforequest.can_add_action(action_type))
            else:
                with self.assertRaisesMessage(expected_result, expected_message):
                    self.assertFalse(inforequest.can_add_action(action_type))

    def test_send_notification(self):
        u"""
        Checks the notification sender and recipients and that it's queued to be sent.
        """
        user = self._create_user(first_name=u'John', last_name=u'Smith', email=u'smith@example.com')
        inforequest, _, _ = self._create_inforequest_scenario(user)
        email, rel = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNDECIDED)

        with self.settings(DEFAULT_FROM_EMAIL=u'info@example.com'):
            with created_instances(Message.objects) as query_set:
                inforequest.send_received_email_notification(email)
        msg = query_set.get()

        self.assertEqual(msg.type, Message.TYPES.OUTBOUND)
        self.assertIsNone(msg.processed)
        self.assertEqual(msg.to_formatted, u'smith@example.com')
        self.assertEqual(msg.cc_formatted, u'')
        self.assertEqual(msg.bcc_formatted, u'')

    def test_send_received_email_notification(self):
        u"""
        Checks that the sent notification contains received email subject and content and a link to
        to decide the received email.
        """
        inforequest, _, _ = self._create_inforequest_scenario()
        email, rel = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNDECIDED,
                subject=u'Received email subject', text=u'Received email text content.')

        with created_instances(Message.objects) as query_set:
            inforequest.send_received_email_notification(email)
        msg = query_set.get()

        url = u'%s#decide' % reverse(u'inforequests:detail', args=(inforequest.pk,))
        self.assertIn(url, msg.text)
        self.assertIn(u'Subject: Received email subject', msg.text)
        self.assertIn(u'Received email text content.', msg.text)

    def test_send_undecided_email_reminder(self):
        u"""
        Checks thet the sent notification contains a link to to decide the received email. Also
        checks that ``last_undecided_email_reminder`` field is updated.
        """
        inforequest, _, _ = self._create_inforequest_scenario()
        email, rel = self._create_inforequest_email(inforequest=inforequest, reltype=InforequestEmail.TYPES.UNDECIDED)

        with created_instances(Message.objects) as query_set:
            inforequest.send_undecided_email_reminder()
        msg = query_set.get()

        url = u'%s#decide' % reverse(u'inforequests:detail', args=(inforequest.pk,))
        self.assertIn(url, msg.text)
        self.assertAlmostEqual(inforequest.last_undecided_email_reminder, utc_now(), delta=datetime.timedelta(seconds=10))

    def test_send_obligee_deadline_reminder(self):
        u"""
        Checks thet the sent notification contains a link to the expired actioon. Also checks that
        its ``last_deadline_reminder`` field is updated.
        """
        timewarp.jump(local_datetime_from_local(u'2010-10-05 10:22:00'))
        inforequest, _, (request,) = self._create_inforequest_scenario()

        timewarp.jump(local_datetime_from_local(u'2010-11-08 11:22:00'))
        with created_instances(Message.objects) as query_set:
            inforequest.send_obligee_deadline_reminder(request)
        msg = query_set.get()

        url = u'%s#action-%s' % (reverse(u'inforequests:detail', args=(inforequest.pk,)), request.pk)
        self.assertIn(url, msg.text)
        self.assertAlmostEqual(request.last_deadline_reminder, utc_now(), delta=datetime.timedelta(seconds=10))

    def test_send_applicant_deadline_reminder(self):
        u"""
        Checks thet the sent notification contains a link to the expired actioon. Also checks that
        its ``last_deadline_reminder`` field is updated.
        """
        timewarp.jump(local_datetime_from_local(u'2010-10-05 10:22:00'))
        inforequest, _, (_, clarification_request) = self._create_inforequest_scenario(u'clarification_request')

        timewarp.jump(local_datetime_from_local(u'2010-11-08 11:22:00'))
        with created_instances(Message.objects) as query_set:
            inforequest.send_applicant_deadline_reminder(clarification_request)
        msg = query_set.get()

        url = u'%s#action-%s' % (reverse(u'inforequests:detail', args=(inforequest.pk,)), clarification_request.pk)
        self.assertIn(url, msg.text)
        self.assertAlmostEqual(clarification_request.last_deadline_reminder, utc_now(), delta=datetime.timedelta(seconds=10))

    def test_repr(self):
        inforequest = self._create_inforequest()
        self.assertEqual(repr(inforequest), u'<Inforequest: %s>' % inforequest.pk)

    def test_owned_by_query_method(self):
        inforequest1 = self._create_inforequest(applicant=self.user1)
        inforequest2 = self._create_inforequest(applicant=self.user2)
        inforequest3 = self._create_inforequest(applicant=self.user2)
        result = Inforequest.objects.owned_by(self.user2)
        self.assertItemsEqual(result, [inforequest2, inforequest3])

    def test_owned_by_query_method_with_no_matches(self):
        inforequest1 = self._create_inforequest(applicant=self.user1)
        inforequest2 = self._create_inforequest(applicant=self.user1)
        result = Inforequest.objects.owned_by(self.user2)
        self.assertItemsEqual(result, [])

    def test_closed_and_not_closed_query_methods(self):
        inforequest1 = self._create_inforequest(closed=True)
        inforequest2 = self._create_inforequest(closed=False)
        inforequest3 = self._create_inforequest(closed=True)
        inforequest4 = self._create_inforequest(closed=False)
        result = Inforequest.objects.closed()
        self.assertItemsEqual(result, [inforequest1, inforequest3])
        result = Inforequest.objects.not_closed()
        self.assertItemsEqual(result, [inforequest2, inforequest4])

    def test_with_and_without_undecided_email_query_methods(self):
        inforequest1, _, _ = self._create_inforequest_scenario(u'confirmation', u'extension')
        inforequest2, _, _ = self._create_inforequest_scenario(u'refusal')
        inforequest3, _, _ = self._create_inforequest_scenario()
        inforequest4, _, _ = self._create_inforequest_scenario()
        self._create_inforequest_email(inforequest=inforequest2, reltype=InforequestEmail.TYPES.UNDECIDED)
        self._create_inforequest_email(inforequest=inforequest3, reltype=InforequestEmail.TYPES.UNDECIDED)
        self._create_inforequest_email(inforequest=inforequest4, reltype=InforequestEmail.TYPES.UNKNOWN)
        result = Inforequest.objects.with_undecided_email()
        self.assertItemsEqual(result, [inforequest2, inforequest3])
        result = Inforequest.objects.without_undecided_email()
        self.assertItemsEqual(result, [inforequest1, inforequest4])
